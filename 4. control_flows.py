### Code that modifies a collection while iterating over that same collection
### can be tricky to get right. Instead, it is usually more straight-forward
### to loop over a copy of the collection or to create a new collection:

# users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}
# for user, status in users.copy().items():
#     if status == 'inactive':
#         del users[user]
        
# print(users)


### In case of lists, don't need to worry about the collection size

# marks_list = [93, 91, 50, 95]
# for index, marks in enumerate(marks_list):
#     if marks < 90:
#         marks_list.pop(index)
        
# print(marks_list)


### range behaves as it is list in many cases but it is not list
### there are differences that exists 

### similarities 

_list = [0, 1, 2, 3, 4]
_range = range(5)


# for value in _list:
#     print(value)
    

# for value in _range:
#     print(value)
    
# print(sum(_list))
# print(sum(_range))

# print(_list[3])
# print(_range[3])


### main differences 

# range generate elements in pattern while 
# list does not necessary follows are pattern. 

# values generated by range functions are successive (based on previous value) 



### loops (break and else)

## In a for loop, the else clause is executed after
## the loop reaches its final iteration.

# for i in range(5):
#     if i % 2 == 0:
#         print(i)
# else:
#     print('I am being terminated')
    
    
## In a while loop, it’s executed after
## the loop’s condition becomes false.

# i = 0
# while (i < 5):
#     if i % 2 == 0:
#         print(i)
#     i += 1
# else:
#     print('I am being terminated')


## In either kind of loop, the else clause is not executed
## if the loop was terminated by a break.

# i = 1
# while (i < 5):
#     if i % 2 == 0:
#         print(i)
#         break
#     i += 1
# else:
#     print('I am being terminated')



## the else clause has more in common with the else
##  clause of a try statement 

# try:
# #     a = 10 / 0
#     print('hello world')
# except Exception:
#     print("welcome to the world of exceptions")
# else:
#     print('I am else')

## pass 

# def fun():
#     pass

        

### documentation string (docstring)

# def add(a, b):
#     'this function adds two numbers'
#     return a + b

# print(add(10, 20))

### local symbol and global symbol table => related to scope

## local vs non-local vs global and modifying global variable

## modifying global variable
# global_variable = 20

# def modifying_global():
#     global global_variable
#     global_variable += 1
    
# modifying_global()
# print(global_variable)

## local vs non local
# def main_function():
#     main_fun_var = 20 
#     def nested_function():
#         print("From Nested Functino ", main_fun_var) #non local
#     nested_function()
#     print('From Main function ', main_fun_var) # local
    
# main_function()



### functions are first class objects 

# def add(a, b):
#     return a + b

# addition = add
# print(addition(2, 3))

# def subtract(a, b):
#     return a - b

# print(subtract(add(2, 8), 5))

## Proceedure vs Function -> Proceedure do not return something


## an alternative to append but append is more efficient

# _list = [1, 2, 3]
# _list += [10]
# print(_list)



## if function calls is called multiple times and default 
## parameter is changed, then changed parameter becomes the 
## next default parameter


# def temp(value, L=[]):
#     L.append(value)

# temp(1)
# temp(2)

## keyword arguments  vs positional arguments
